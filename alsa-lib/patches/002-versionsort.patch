--- alsa-lib-1.0.24.1.orig/src/ucm/parser.c	2011-03-13 21:17:10.405058674 +0300
+++ alsa-lib-1.0.24.1/src/ucm/parser.c	2011-03-13 21:26:24.705183404 +0300
@@ -32,6 +32,9 @@
 
 #include "ucm_local.h"
 #include <dirent.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdint.h>
 
 /** The name of the environment variable containing the UCM directory */
 #define ALSA_CONFIG_UCM_VAR "ALSA_CONFIG_UCM"
@@ -40,6 +43,100 @@
 			  struct list_head *base,
 			  snd_config_t *cfg);
 
+	/* states: S_N: normal, S_I: comparing integral part, S_F: comparing
+	   fractional parts, S_Z: idem but with leading Zeroes only */
+	#define  S_N    0x0
+	#define  S_I    0x4
+	#define  S_F    0x8
+	#define  S_Z    0xC
+	
+	/* result_type: CMP: return diff; LEN: compare using len_diff/diff */
+	#define  CMP    2
+	#define  LEN    3
+	
+	/* using more efficient isdigit() */
+	#undef isdigit
+	#define isdigit(a) ((unsigned)((a) - '0') <= 9)
+	
+	/* Compare S1 and S2 as strings holding indices/version numbers,
+	   returning less than, equal to or greater than zero if S1 is less than,
+	   equal to or greater than S2 (for more info, see the texinfo doc).
+	*/
+	int strverscmp (const char *s1, const char *s2)
+	{
+	  const unsigned char *p1 = (const unsigned char *) s1;
+	  const unsigned char *p2 = (const unsigned char *) s2;
+	  unsigned char c1, c2;
+	  int state;
+	  int diff;
+	
+	  /* Symbol(s)    0       [1-9]   others  (padding)
+	     Transition   (10) 0  (01) d  (00) x  (11) -   */
+	  static const uint8_t next_state[] =
+	  {
+	      /* state    x    d    0    - */
+	      /* S_N */  S_N, S_I, S_Z, S_N,
+	      /* S_I */  S_N, S_I, S_I, S_I,
+	      /* S_F */  S_N, S_F, S_F, S_F,
+	      /* S_Z */  S_N, S_F, S_Z, S_Z
+	  };
+	
+	  static const int8_t result_type[] =
+	  {
+	      /* state   x/x  x/d  x/0  x/-  d/x  d/d  d/0  d/-
+	                 0/x  0/d  0/0  0/-  -/x  -/d  -/0  -/- */
+	
+	      /* S_N */  CMP, CMP, CMP, CMP, CMP, LEN, CMP, CMP,
+	                 CMP, CMP, CMP, CMP, CMP, CMP, CMP, CMP,
+	      /* S_I */  CMP, -1,  -1,  CMP, +1,  LEN, LEN, CMP,
+	                 +1,  LEN, LEN, CMP, CMP, CMP, CMP, CMP,
+	      /* S_F */  CMP, CMP, CMP, CMP, CMP, LEN, CMP, CMP,
+	                 CMP, CMP, CMP, CMP, CMP, CMP, CMP, CMP,
+	      /* S_Z */  CMP, +1,  +1,  CMP, -1,  CMP, CMP, CMP,
+	                 -1,  CMP, CMP, CMP
+	  };
+	
+	  if (p1 == p2)
+	    return 0;
+	
+	  c1 = *p1++;
+	  c2 = *p2++;
+	  /* Hint: '0' is a digit too.  */
+	  state = S_N | ((c1 == '0') + (isdigit (c1) != 0));
+	
+	  while ((diff = c1 - c2) == 0 && c1 != '\0')
+	    {
+	      state = next_state[state];
+	      c1 = *p1++;
+	      c2 = *p2++;
+	      state |= (c1 == '0') + (isdigit (c1) != 0);
+	    }
+	
+	  state = result_type[state << 2 | (((c2 == '0') + (isdigit (c2) != 0)))];
+	
+	  switch (state)
+	  {
+	    case CMP:
+	      return diff;
+	
+	    case LEN:
+	      while (isdigit (*p1++))
+	    if (!isdigit (*p2++))
+	      return 1;
+	
+	      return isdigit (*p2) ? -1 : diff;
+	
+	    default:
+	      return state;
+	  }
+	}
+
+int versionsort(const void *a, const void *b)
+{
+	return strverscmp((*(const struct dirent **) a)->d_name,
+		(*(const struct dirent **) b)->d_name);
+}
+
 /*
  * Parse string
  */
